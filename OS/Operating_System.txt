- OS from Tanenbaum text book

- instruction : lệnh
- abundance: sự phong phú

Nguyên lý hệ điều hành
- Có 2 nguyên lý hoạt động trong máy tính
kernel mode: hệ điều hành (quyền truy cập mọi tài nguyên hardware, I/O devices..)
user mode : chương trình phần mềm khác
1. Khái niệm hệ điều hành: 
- P34
Cung cấp người lập trình hệ thống một thệ thống tài nguyên
trừu tượng, thay vì một loạt các đối tượng phần cứng, đồng 
thời quản lý tài nguyên phần cứng đó.

1.1 
xếp theo mức độ trừu tượng:
ổ cứng --> disk driver --> file
File ở mức độ trừu tượng cao hơn, cung cấp khả năng giao tiếp
với ổ cứng cho ứng dụng và người lập trình, thay vì việc phải cần
hiểu rõ về hoạt động của ổ cứng

1.3.1 Processors 
- CPU lấy câu lệnh từ bộ nhớ, giải mã và thực thi (fetching - decoding - executing )
- Truy cập vào bộ nhớ là việc tốn kém so với việc thực thi câu lệnh

- Vì vậy cần thanh ghi (regsiter) để lưu dữ liệu
- Thanh ghi vs RAM: thanh ghi lưu data , RAM lưu cả câu lệnh và data

- Các thanh ghi: program counter, stack pointer, PSW (program status word)
Win 32 bit: thanh ghi 32 * 32 bit, win 64; thanh ghhi 64 * 64 bit

- PSW thường chứa dữ liệu kiểm soát giữa việc thực thi câu lệnh ở
kernel mode và user mode (dữ liệu if/else chuyển đổi việc thực thi câu lệnh
ở kernel hay user mod)
- System call : thủ tục đặc biệt chuyển từ mode user sang mode kernal (TRAP)
- Đa luồng: (multithreading) cung cấ khả năng chuyển ngữ cảnh từ thread khác
nhau với tốc độ cao vì CPU lưu giữ được trạng thái của nhiều luông cùng 
một lúc, tuy nhiên vẫn chỉ có 1 process đang hoạt động 
GPU: có hàng nghìn core, xử lý rất tốt các tác vụ song song, ko phù
hợp với các tác vụ lần lượt

1.3.2 Bộ nhớ
Thanh ghi -> Cache --> Main memory --> Disk
Flash disk có tốc độ ở giữa so với RAM và ROM, tuy nhiên nếu dữ liệu bị xóa nhiều 
lần bộ nhớ sẽ bị hao mòn
Thanh ghi : 32* 32 bit với win 32, 64 * 64 bit với win 64
Cache sử dụng cache line (cache hit vs cache miss)

1.3.3 Disks
Dùng bộ nhớ ảo: (virtual memory) : cho chương trình chạy trên Disk và
dùng RAM như bộ nhớ cache (thay vì chương trình chỉ chạy trên ram)
--> không gian bộ nhớ lớn hơn, tuy nhiên yêu cầu cần phải mapping địa 
chỉ đã được located trong RAM. Công việc mapping này được xử lý bởi MMU 
(Memory Management Unit)

1.3.4 I/O Devices
- Gồm 2 phần: controller và device
- Controller là những con chip, nhận yêu cầu từ OS và điều khiển devices
- Controller cung cấp 1 tầng trừu tượng hóa để giao tiếp với device hiệu quả hơn
1. Tiêu chuẩn của disk: SATA tiêu chuẩn disk của IBM (serial advanced technology attachment)
2. Device -> Controller -> Driver (dùng để giao tiếp với controller của device) 
3. Driver thường sẽ được đặt vào OS và chạy ở kernel mode
4. Các cách đặt driver vào kernel
    4.1 Relink kernel với driver mới, sau đó reboot system (dùng trong Unix)
    4.2 Tại đường dẫn + reboot system, tại thời điểm reboot, hệ điều hành sẽ load driver cần thiết (dùng trong window)
    4.3 Cài đặt driver dynamically, không cần reboot (ví dụ USB, IEEE device khi được sử dụng sẽ cần load drivers phù hợp
        mà không cần reboot lại hệ thống)
5. Mỗi controller có những thanh ghi để OS giao tiếp với nó. Ví dụ disk có các thanh ghi để lưu trữ: địa chỉ disk, 
địa chỉ bộ nhớ, số lượng sector
Trong nhiều hệ thống, thanh ghi thiết bị (device registers) được ánh xạ đến không gian để chỉ của OS nên
nó được đọc và ghi như 1  địa chỉ thông thường. Ở những thiết hệ thống khác,
 thanh ghi thiết bị được đặt vào I/O port space và có địa chỉ cổng riêng.
5. Có 3 cách gọi Input vs Output 
        5.1 User gọi lời gọi hệ thống, lời gọi được chuyển thành lời gọi thủ tục (procedure call) đến driver phù hợp.
            Driver sẽ start I/O và giám sát thiết bị đã hoạt động hoàn thành hay chưa (busy waiting: vì CPU sẽ phải đợi đến thi 
            thiết bị hoàn thành)
        5.2 Tạo ra 1 interupt để báo hiệu công việc I/O đã hoàn thành. Trong OS có interrupt controller để kiểm soát yêu cầu ngắt 
            từ nhiều thiết bị khác nhau. Mỗi thiết bị có interrupt handler để thông báo interrupt của device đó, tùy theo mức độ
            ưu tiên của device mà interrupt tương ứng sẽ được xử lý.
            Đoạn cuối về interrupt chưa hiểu lắm
        5.3 Sử dụng phần cứng đặc biệt: DMA (Direact Memory Access)

1.3.5 Buses
- Xem thêm phần ghi chú trên công ty ...
SCSI (Small Computer System Interface): bus hiệu năng cao, dùng cho disk tốc độ cao
máy quét...
- plug and play (cắm là chạy): tự động cung cấp interupts level, địa chỉ I/O, 
- Có nhiều bus trong hệ thống: cache, memory, PCIe..., bus chính trong máy tính là PCIe
PCIe sử dụng serial bus architecture (thay vì parallel bus architexture) -> dữ liệu gửi hết 
trên một đường (called lane)
(Xem hình 1-12: page 63)
- CPU giao tiếp với memory bằng DDR3 bus
- CPU giao tiếp với thiết vị bên ngoài bằng PCIe (Peripheral Component Interconnect Express) bus
- Giao tiếp với các thiết bị khác qua Hub thông qua bus DMI (Direct Media Interface)
- Hub kết nối tất cả các thiết bị dùng USB

1.3.6 Booting PC 
- Trong PC có parentboard, trên đó chứa BIOS (basic inout ouput system)
BIOS chứa low-level I/O software, thủ tục đọc bàn phìm, ghi màn hình ...
BIOS chứa ở flash RAM nên ko bị mất khi máy tính tắt.
Khi PC được booted, BIOS sẽ check bao nhiêu RAM đc cài đặt, các thiết bị khác được
phản hồi đúng chưa. bằng cách scan PCIe. Sau khi scna, BIOS kiểm tra các device
đã có đầy đủ drive chưa, nếu chưa có sẽ yêu cầu cài đặt 

1.4 Các hệ điều hành
1.1.4 Mainframe 
Máy tính cỡ lớn
3 chức năng chính: xử lý hàng loạt, xử lý giao dịch, time sharing
Đang được thay thế bởi các hệ điều hành dạng UNIX như LINUX



1.5 
1.5.1 Processes (Tiến trình)
- Là chương trình đang được thực thi
- Gắn với mỗi tiến trình là 
    + Không gian địa chỉ
    + Tài nguyên khác (file, đồng hồ, thanh ghi, tiến trình khác)
-> giống như 1 container chứa tất cả thông tin cần thiết để chạy chương trình

- Trường hợp process bị tạm dừng (suspend), thông tin về process sẽ được lưu lại trong process table
- Mỗi process được khởi chạy sẽ có UID của user kích hoạt, giá trị UID được gán bởi system administrator.
UID trong UNIX được gọi là supperuser, windows là Administrator


1.5.2 File 
- Đường dẫn tuyệt đối: đường dẫn đi từ nút gốc
- Đường dẫn tương đối: khi đang đứng ở 1 folder chỉ cần cung cấp đường dẫn tương đối của 1 địa chỉ
- window dùng \ để ngăn cách trong đường dẫn, unix dùng dấu /
- Nếu file được mở thành công, 1 số nguyên file descriptor (định danh cho file được mở) sẽ được trả về để sử dụng
 cho các hoạt động tiếp theo
- Mounted file system: gắn các bộ nhớ như USB, CD, DVD thành các thư mục con nằm cùng với thu mục file của máy Tính
-> dễ dàng truy xuất dữ liệu

1.5.3 Protection
- Trong Unix: sử dụng 9 ký tự biểu đạt, mỗi 3 ký tự đại diện cho 3 user, owner - other group - every one
VD rwxr-x---x 
-> owner được sử dụng cả 3 quyền với tài nguyên
-> group: được sử dụng 2 quyền đọc và thực thi
-> every one : được duy nhất quyền thực thi file này

1.6 System call
- OS có 2 nhiệm vụ chính: cung cấp tài nguyên trừu tượng trong hệ thống + quản lý tài nguyên
- System call: như 1 lời gọi đến tài nguyên máy tính ở mức kernal (vd đọc ghi file)
- procedure call : là việc gọi 1 hàm trong cùng 1 chương trình, khác với system call
- Ví dụ lời gọi hệ thống trong việc đọc file : trang 83

POSIX system calls là interface cung cấp system call cho ứng dụng chạy trên nhiều hệ điều hành khác nhau
các system call của POSIX
    + read, write, socket(), bind() ...

- Lời gọi hệ thống để  (trang 85)
    + quản lý process
        . fork: tạo ra tiến trình con với tham số giống với tiến trình cha, sau đó 2 tiến trình sẽ có data khác nhau 
        và không hề ảnh hưởng lẫn nhau. Để phân biệt tiến trình cha và con dựa vào PID (id process children) (chú ý PID 
        chỉ xuất hiện ở tiến trình cha)
        . main(argc, argv, envp) : chương trình thực thi. VD với lệnh cp file1 file 2, argc: count số phần tử trong câu lệnh
        argv: mảng chứa các phần tử trong câu lệnh (command), envp :  pointer to the environment (vd  directory name ...)
        . 1 tiến trình (process trong UNIX có bộ nhớ gồm 3 phần: text, data, stack). Bộ nhớ stack có địa chỉ giảm dần. Bộ nhớ
        stack tự động grows, bộ nhớ data thì cần có system call để thực hiện việc grows.
        bộ nhớ data có địa chỉ tăng dần
    + quản lý File
        . Lệnh link(src/user1/file1, src/user2/file2): chia sẻ file đến một địa chỉ khác, với tên gọi có thể khác nhau. Tuy nhiên
        2 file này có cùng tham chiếu đến địa chỉ file thông qua unique number (trong UNIX)
        . Trong UNIX, directory là file lưu cặp giá trị (i-number, name-file).
    + quản lý thư mục (directory)

- Các loại lời gọi hệ thống với file và directory
+ chdir (cd): change directory
+ chmod: thay đổi mode của file (vd: rwer--r-e)

- Trong UNIX system call và library call là coupling (liên quan chặt chẽ với nhau: 
mỗi system call sẽ kèm theo 1 library call)
- Trong windows, điều này được cải thiện bằng cách decoupling library call và system call
system call trong window thực hiện qua các API trung gian: ví dụ sử dụng system 32 API 
và .NET framework
- Trong khi đó trong UNIX system call được thực hiện thẳng ở các ứng dụng

1.7 Cấu trúc của OS
1.7.1 Monolithic Systems
- chỉ có 1 program duy nhất chạy ở kernel
- Tất cả các procedure sẽ được compiles và binding thành 1 file thực thi duy nhất, và được gọi bất cứ 
khi nào chương trình cần
- Cấu trúc của OS trong trường hợp này
    + program sẽ gọi đến service procedure
    + service procedure sẽ thực hiện lời gọi hệ thống
    + utility procedure sẽ hỗ trợ service procedure
    - ngoài ra còn có các extension: vd trong window cố ddl (dynamic link library), Unix có shared library

1.7.2 Layer Systems
- Chia hệ thống thành các layer, từng layer đảm nhiệm chức năng riêng
 các layer đều hoạt động ở kernel dẫn đến trường hợp phía dưới
- Nếu có nhiều process hoạt động, nếu 1 process hoạt động sai có thể 
dẫn đến cả hệ thống có thể hoạt động sai.
VD 1 chương trình sử dụng bộ nhớ và phân bổ bộ nhớ sai dẫn đến các chương trình khác sử 
dụng bố nhớ sai theo


1.7.3 Microkernels
- chia OS ra thành những phần nhỏ, chỉ có Microkernels chạy ở tầng kernell.
Với mỗi ứng dụng có driver riieeng chạy trên tầng user, và ko thể truy cập trực tiếp
vào tài nguyên kernel như bộ nhớ ... mà phải thông qua thông qua kernel call

user program  --> server  ---> driver ---> kernel

- để giảm tải kernel, áp dụng cơ chế: kernel (chứa machanism), user (chứa policy)
Ví dụ việc áp dụng priorities cho tiến trình, việc xác điịnh priorities là machanism thực 
hiện ở kernel, nhưng việc gán priorities cho tiến trình được thực hiện ở mức user

1.7.4 Client -server
- là 1 biến thể của Microkernels

1.7.5 virtual machines
- có máy ảo giống với hardware thật, nên có thể chạy bất kỳ OS nào chạy trên máy thật
- VM dùng để tăng tương tác, timesharing giữa các chương trình, tiến trình trên hệ thống
VMware, virtual box là các hypervisors (= virtual machine monitor ) thực hiện việc ảo hóa trên máy tính
dùng để quản lý nhiều máy ảo khác nhau trên máy tính
- type 1 hypervisor: hypervisor cài trực tiếp trên OS -> các máy ảo cũng được thao tác
trên chính phần cứng đó (dùng trong các máy tính doanh nghiệp)
- type 2 hypervisor: hypervisor được cài đặt như 1 tầng trung gian giữa máy ảo và OS thật của 
hệ thống (dùng trong máy tính cá nhân)
"the real distinction between a type 1 hypervisor and a type 2 hypervisor is that a type 2 makes
 uses of a host operating system and its file system to
create processes, store files, and so on. A type 1 hypervisor
 has no underlying support and must perform all these functions itself"

- Để dùng được máy ảo, CPU cần được hỗ trợ việc ảo hóa, nếu không cần có interpreters hỗ trợ việc này.
VD Bochs trong Pentium 

machine simulators: improve Bochs bằng việc dịch khối code, lưu vào cach, tái sử dụng.

- Java Virtual Machine: Java compiler sẽ dịch code thành  byte-code để JVM có thể chạy được
(khác với C, code được biên dịch thành mã máy)
1.7.6 Exokernels
- Phân chia tài nguyên cho từng virtual machine, thay vì phải tạo ra 1 layer ở trung gian 
giữa các VM và tài nguyên hệ thống

1.8 Lập trình C
C được dùng để xây dựng windows
- để xây dựng project lớn,mỗi file .c (chứa code) sẽ được biên dịch thành object file (.o) chứa câu
lệnh nhị phân (binary instruction). Tất cả các file .o này sau đó được đưa đến linker tạo
thành single executable binary file

- Trong 1 chương trình có số lượng lớn file header, việc thay đổi 1 file sẽ ảnh hưởng đến rất 
nhiều file khác gọi đến nó, khi đó thời gian compile là rất tốn kém. Vì vậy trong các 
hệ điều hành cần có công cụ hỗ trợ việc này.


============ Tổng kết ========
Trả  lời quiz cuối bài: 
https://quizlet.com/192906075/os-test-one-flash-cards/  
- khác nhau của multi-programming vs time-sharing
+ multi-programming: với mục đích sử dụng tối đa CPU (CPU không được có thời gian rảnh)
+ trong timesharing: mục đích là giảm thời gian response -> CPU phân bổ cho từng tiến trình 1

- trap vs interrupt: 
trap là synchronous interrupt xảy ra ở tiến trình người dùng, dùng để chuyển từ user mode
sang kernel mode
interrupt: tín hiệu yêu cầu CPU xử lý, tạo ra từ phần mềm / phần cứng


=============== II. Process =================
- Tiến trình là chương trình đang thực thi
- Nhờ có tiến trình, single CPU có khả năng hoạt động như multiple virtual CPU
Cụ thể: khi 1 server nhận được 1 request, server sẽ kiểm trả kết quả trả về đã có trong cache
hay chưa, nếu có lấy thông tin từ cache, ngược lại sẽ yêu cầu truy cập vào disk và lấy dữ liệu.
Quá trình fetching dữ liệu từ disk là tốn thời gian, và trong khoảng thời gian này CPU sẽ 
thực hiện đáp ứng cho các request khác. Để đảm bảo các công việc này diễn ra 1 cách đồng thời, 
cần có 1 công cụ để đáp ứng --> giải pháp: process và thread
- Khi máy tính người dùng khởi động, có rất nhiều tiến trình hoạt động: tiến trình emaiil, diệt virus,
... 
- Multiprogramming hỗ trợ multiprocessing
- trong Multiprogramming CPU chuyển qua lại giữa process rất nhanh.
- tại 1 thời điểm 1 CPU chỉ chạy trên 1 process, tuy nhiên với mỗi process thời gian CPU dành
cho việc xử lý là khoảng  10 - 100 ms. Dẫn đến trong 1s, có thể xử lý rất nhiều process và 
tạo cảm giác như việc thực thi là song song (parallel)

2.1 The Process Model
- mỗi phần mềm, OS là tập hợp các process
- process là 1 chương trình đang thực thi, bao gồm thông tin về program counter, registers, and variables
- một cpu thực thi 1 process tại 1 thời điểm
- VD tương quan process: việc nấu ăn gồm công thức (program), nguyên liệu (data), người
nấu (processor) -> việc thực hiện công việc nấu ăn chính là 1 process

2.1.2 Process Creation
các event khởi tạo process
+ khởi động hệ thống
+ 1 process (tiến trình) đang chạy thực hiện lời gọi hệ thống để khởi tạo 1 process
+ user request 
+ khởi động batch job


- có 2 loại process: foreground (giao tiếp với chương trình users) vs background
- deamons: là những tiến trình chạy ngầm dưới (background) 
- tiến trình con được tạo ra từ tiến trình cha: trong UNIX tiến trình con ban đầu sẽ có
địa chỉ giống tiến trình cha, sau đó nếu muốn ghi đè nội dung vào bộ nhớ sẽ được cấp 
1 bộ nhớ mới là bản copy của bộ nhớ cũ. Ngược lại trong windows, tiến trình con đó sẽ được cấp 
ngay bộ nhớ mới

2.1.3 Process Termination
Xảy ra khi: kết thúc công việc, error, killed by other process

2.1.4 Process hierachy
- Trong UNIX, sẽ có những process con được liên kết với process cha hình thành nên process hierachy.
Data sẽ được truyền trong cả cây process này.
- Trong window, mọi process đều là ngang hàng

2.1.5 Process state
3 trạng thái chính
- running (đang chạy và đang sử dụng CPU)
- ready (sẵn sàng chạy nhưng CPU chưa được cung cấp để thực thi)
- blocked (chỉ được chạy nếu có sự kiện bên ngoài kích hoạt)
- scheduler có nhiệm vụ phân bổ thời gian cho việc thực thi các tiến trình trong máy tính
- 

2.1.6 Implementation of Processes
- Sử dụng process table chứa rất nhiều process control blocks (PCB)
- PCB chứa thông tin về: program counter, stack pointer, memory allocation, open files.
Thông tin này sẽ được dùng lại nếu procesor chuyển từ tiến trình khác về lại tiến trình cũ thực thi
- interrupt vector chứa thông tin về interupt service procedure
- Khi có interrupt, sẽ lưu thông tin registers của process hiện tại đầu tiên


2.1.7 Modeling programming
- degree of multiprogramming: (mức độ đa chương trình)  khả năng thực thi đa chương trình của CPU
-