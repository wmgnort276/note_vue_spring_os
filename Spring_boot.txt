pass mysql :
Nam276201@


Shift + enter : create new line at middle of current line
alt + insert : insert getter, setter, toString method
sout: short cut for System.out.println()
@JsonIgnore: đánh dấu trường là ko cần thiết (ví dụ khi map object)

============= 
Đối tượng Authentication đại diện cho token của user đã được xác thực
đối tượng này được chứa trong SecurityContextHolder 
- các phương thức: getDetails, getPrinciple(), isAuthenticated()
getPrincipal(): trả về đối tượng UserDetails
===================
AuthenticationManager có DaoAuthenticationProvider nhằm xác thực username, 
password, nếu username password thỏa mãn sẽ trả lại một đối tượng Authentication

================
Method parse() trong java
- Dùng để extract thông tin cần thiết, thường là extract từ string để lấy thông 
tin (VD thông tin Date lưu dưới dạng String)

=========================== 
// Upcasting is rarely used 
upcasting : Parent p =(Parent) new Child();

downcasting: Parent p = new Child();
	     Child c = (Child) p;

==================== @Lob ====================
Lob Data in Hibernate
Gồm 2 loại
CLOB: character large object chứa dữ liệu text lớn
BLOB: Binary Large object chứa dữ liệu nhị phân như ảnh video,audio


============= Persist trong hibernate java========
- Chuyển đổi trạng thái entity sang câu lệnh sql
- Persist chuyển entity từ trạng thái transitent sang trạng thái 
persistance (trạng thái bền vững)
- Gọi đến persist method sẽ thực thi câu lệnh insert (làm cập nhật id entity)
 thay vì phải đợi đến flush time để làm điều này

========= Flush time ========
- thời diểm JPA-Hibernate đồng bộ hóa các thay đổi của entity xuống DB
- Trong JPA, đây là thời điểm mà các câu truy vấn kết nối đến DB

============== Vòng đời entity trong Hibernate và JPA============
https://techmaster.vn/posts/36269/trang-thai-cua-entity-thuc-the-trong-hibernate-va-jpa

Persistence context quản lí entity
1. Trạng thái new (Transient): entity mới đc khởi tạo
2. Persistent (Bến bỉ): khi data được ánh xạ vào DB và quản lý bởi Persistence Context
Thay đổi được ghi nhận vào db trong lện session Flush.
Nếu đối tượng ở trạng thái này, ko cần gọi save hay update khi commit transaction
flush sẽ cập nhật xuông DB
3. Detached (ta)


============ JPA===============
Java persistence: cách quản lý dữ liệu trong ứng dụng, ánh xạ table trong DB
sang mối quan hệ của object
- Sử dụng EntityManager (interface) để tương tác với các entity

============ Hiberbnate=========
- Giúp thao tác với DB thông qua các đối tượng, impliment JPA
- Sử dụng session để tương tác entity

============= So sánh JPA và JDBC ============
- JDBC (DB connectivity): dùng để tương tác với DB (config trong file application)
- JDBC: hỗ trợ viết sql command để tương tác, đọc dữ liệu từ BD, cần viết cả
câu query thay vì dùng anotaion như trong JPA
- JDBC: cần viết code trong try catch block vì JDBC throw exceptions

- JPA: hỗ trợ cấu trúc hóa đối tượng thành bảng trong DB, gần với ngôn ngữ
hướng đối tượng, hạn chế việc phải check lại liên tục sự thay đổi giữa object trên BE
và DB


=========== annotation in JPA: oneToMany, OneToOne, ManyToOne, ManyToMany======
Link
https://dev.to/jhonifaber/hibernate-onetoone-onetomany-manytoone-and-manytomany-8ba

- @OneToOne: @JoinCollumn sẽ quyết định việc entity hiện tại chứa Foreing key của 
entity khác


============= Lấy thông tin ID user ============
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();


================ Spring validation ============
- Dùng để validate input của người dùng


=========== @Notblank, @NotNull, @NotEmpty =============
- Các annotation này không ảnh hưởng đến constrant DB
- Nếu muốn update trong DB, thêm nullable = false vào @Collumn(nullable = false)
hoặc @JoinCollumn()
- @NotNull: field ko thể null, có thể empty ("")
- @NotEmpty: field không thể null, và ko thể empty, thêm @Size(min = 2, max = 10)
- @NotBlank =  @NotEmpty và dữ liệu được trim


==============================================================
============= 1. Facade Java: (1 kiểu design pattern) ================
- Trong một hệ thống có nhiều hệ thống con, mỗi hệ thống con đảm nhận
một công việc khác nhau, khi đó Facade giống như 1 lớp bên ngoài giao 
tiếp với client, có chức năng cung cấp dịch vụ mà hệ thống con đó cung cấp.
VD: Hệ thống cửa hàng phụ vụ nhiều yêu cầu: đặt hàng, thanh toán, dịch vu
riêng -> Facade là nhân viên tổng đài phục cụ, làm nhiệm vụ giao tiếp với
khách hàng, cung cấp và phục vụ cho lựa chọn của họ.

======================================================
============ 2. Các kiểu design patterns ==============
https://tuan200tokyo.blogspot.com/2022/10/blog10-gioi-thieu-ve-javascript-design.html
https://www.digitalocean.com/community/tutorials/java-design-patterns-example-tutorial
Các kiểu design pattern trong java:
https://stackjava.com/category/design-pattern

- Singleton Patterns: một lớp chỉ có 1 instance duy nhất, bất biến
- Adapter: tạo một lớp trung gian để giao tiếp với interface hoặc class khác
- Factory Method Pattern: các đối tượng có thể sửa đổi
https://viblo.asia/p/factory-method-pattern-trong-java-4dbZNoNQlYM
	+ Tạo 1 interface, abstract class sau đó tạo 1 class để implment
	sau đó trạo Factory class bên trong đó có phương thức 
	khởi tạo Object chúng ta cần -> xFactory.getX(), object được lấy 
       	phụ thuộc vào đầu vào (type)
VD: factory 
public interface Phone{
	trong đây có list các thuộc tính
}
public class Iphone implement Phone { }
public class SamsungPhone implement Phone { }
public class PhoneFactory {
	public Phone getPhone(Phone_Type)
}

- Abstract Factory Pattern:  chứa nhiều factory class bên trong
- Provider:  tạo 1 interface và nhiều provider implement interface đó, 
mỗi class riêng sẽ thực hiện chức năng riêng

- Builder pattern: xử lý tồn đọng với Factory và abstract factory nếu Object có
nhiều thuộc tính, builder pattern sẽ cung cấp cách xây dựng đối tượng từng
bước một và cung cấp phương thức trả về đối tượng đó. Thường chứa method 
build tạo ra đối tượng với nhiều thuộc tính

- Composite pattern (structural pattern)
(Tương tác với các đối tượng tương tự nhau giống  như các đối 
tượng đơn trong cùng 1 list)


- dependency injection : là 1 phương pháp thực thi. Factory patterns là 1 phương pháp thực thi DI

=============================================
================== 3. JWT ==================
- Server ký bằng khóa riêng của server, gửi jwt lại cho user đính kèm 1 request
-> mục đích là để xác thực user, ko có khả năng bảo mật thông tin người dùng

===========================================================
======================  4. IOC  ==============================
            loadingData.loadingOfficeRoot



===========================================================
====================== Java OOP==================
- Upcasting
Parent p = (Parent) new Child();
-> rarely used

- Không thể downcast trực tiếp
Child child = new Parrent();  // -> compile error

- Downcast :
Parent a = new Child();
Child b = (Child) a;


==================== Custome mapping using Mapperfacade Orika =======================


Học từ document spring 2.3.4 
https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/htmlsingle/#using-boot
==== starter dependency ======
- Chứa 1 set các dependency trong application
VD  spring-boot-starter-data-jpa: dùng Spring và JPA access vào database

===== Tên packages ============
- packages name, tên packages: dùng để xác định file jar cần chạy nếu sử dụng
các anotaion.  Nếu không, spring boot không thể xác định được file jar cần chạy

@SpringBootApplication = @EnableAutoConfiguration + @ComponentScan + @Configuration
@Configuration giúp class có thể đăng ký thêm các beans 
Nếu sử dụng @ComponentScan, tất cả các component với annotation @Component, @Service , @Repository ...
sẽ tự động được đăng ký

- Dùng @Import để import các configuration classes
- Hoặc có thể dùng @ComponentScan để tự động pick up tất cả các component
- @SpringBootApplication(exclude={DataSourceAutoConfiguration.class}) : dùng để disable auto-configuration 

2. Các tính năng spring boot
- Lazy initialization: bean chỉ được khởi tạo nếu có http request thay vì được khởi tạo lúc ứng
dụng khởi chạy


==== Toán tử :: trong stream list ==========
Toán tử :: : method reference operator
Tương đương lambda expression


=========== Java basic ============
I. Java String
https://www.javatpoint.com/java-string
- String, StringBuffer, StringBuilder: đều tạo string
1. String
	1.1 String: (immutable - bất biến) tạo đối tượng không thay đổi, khi sử dụng các phương thức làm thay đổi đối tượng, 1 instance mới
	sẽ được tạo ra. Trừ trường hợp khởi tạo new String("string"), khi đó JVM sẽ khởi tạo đối tượng riêng cho String này
	1.2 String là object, nếu tạo mới 1 String đã tồn tại trc đó, JVM sẽ chỉ khởi tạo reference đến String đó. String được chứa trong vùng 
	nhớ đặc biệt (string constant pool)
	1.3 VD
		String s1 = "hello";
		String s2 = new String("Hello"); => object được tạo ngoài pool -> s1 != s3
    1.4 Khi String dùng method concat, thực thế là đang sử dụng StringBuilder().append() để nối xâu
	1.5 String.format("%s%s", s1, s2);
	1.6 Khi so sánh string, giá trị của chuỗi được so sánh

2. StringBuffer
- Tạo ra String có thể thay đổi (mutable)
- Khi so sánh, reference được so sánh với nhau
- Khôn overide equals() method của String
- Dùng Heap memory lưu string
3. StringBuilder 
- Tạo ra String có thể thay đổi (mutable) (khác với StringBuffer vì StringBuilder là non-synchronize)


4. So sánh String
	4.1 equals: so sánh content của string
	4.2 == operator: so sánh sử dụng tham chiếu của String
	4.3 compare to trả về 1 giá trị: == trả về 0, lớn hớn trả về 1, nhỏ hơn trả về -1
5. Inner class
https://www.javatpoint.com/member-inner-class
5.1 Inner class là con của nested class. Nếu class bên trong là non-static nó sẽ được coi là inner-class
5.2 


6. Exception Handling 
- Là object throw lúc runtime, handling exceptions giúp các đoạn code phía sau khi xảy ra exceptions vẫ hoạt động
- Check exceptions: được checked ở compile-time. VD: IOException, SQLExceptions
- Unchecked  exceptions: các exceptions ở RuntimeException

Throwable 
		Error
				StackOverflowError
				VirtualMachineError
				OutOfMemoryError
		Exception
				IOException
				SQLExceptions
				CLassNotFoundException
				RuntimeException
						ArithmeticException
						NullPointerException
						NumberFormatException
						IndexOutOfBoundException
								ArrayIndexOutOfBoundsException
								StringIndexOutOfBoundsException

- Với Unchecked Exception: dùng trong function, block of code  (có thể propagate)
- Với Checked Exception: cần throws trong định nghĩa method (method signature), chỉ có thể được propagate khi dùng với throws 
trong method signature
VD: public void method() throws Exception {

}
Khi method định nghĩa bằng từ khóa throws, khi gọi method cần catch exception đã định nghĩa hoặc thêm signature của exception
ở method bên ngoài gọi đến method đó
- Có thể custome Exception, super message của class exceptions cha

- throw vs throws: 
https://www.javatpoint.com/difference-between-throw-and-throws-in-java
throw: tại 1 thời điểm chỉ được throw 1 exception
throws: có thể throws nhiều exception tại 1 thời điểm, có thể dùng với cả checked và Unchecked exception


- method overiding sử dụng exception handling
	- Nếu method ở class cha ko định nghĩa exception, method overide ở class con cũng ko thể định nghĩa checked exception
	- Nếu method ở class cha ko định nghĩa exception, method overide ở class có thể định nghĩa unchecked exception
	- Nếu method ở class cha có định nghĩa exception, method overide có thể khai báo exception nhỏ hơn hoặc bằng exception đó, hoặc ko nhưng ko thể khai
	báo exception cha (parent cuae exception định nghĩa ở method của class cha)


7. Java I/O 
- Dùng package java.io
- stream là 1 chuỗi dữ liệu (sequence of data)
- System.out: ouput stream tiêu chuẩn
- OuputStream: dùng đẻ ghi dữ liệu đến đích (file, thiết bị ngoại vi, socket ...)
	- Các method trong OuputStream: write (ghi byte / array of bytes), flush (flust ouput stream), close ...
	- FileOutputStream: ghi file, sử dụng bytes. Ghi string cần chuyển sang bytes : s.getBytes() (return byte[])


- InputStream: đọc data từ file... 
	- Các method: read (đọc từng byte, trả về -1 nếu đọc đến cuối file), available (trả về số lượng byte có
	 để đọc từ input stream hiện tại)

=========== Paging =================






